{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Seeqret: Safely transferring code secrets (very much a work in progress) Seeqret: Safely transferring code secrets Introduction Prior art... Assumptions Minimum Requirements Use cases Code Introduction How do you communicate the set of secrets (passwords, API keys, etc.) that your code needs to run? You can't just write them in the code, because that would expose them to anyone who can read the code. You can't just send them in an email, because that would expose them to anyone who can read your email. You can't just write them on a sticky note, because that would expose them to anyone who can read your sticky note.","title":"Home"},{"location":"#seeqret-safely-transferring-code-secrets","text":"(very much a work in progress) Seeqret: Safely transferring code secrets Introduction Prior art... Assumptions Minimum Requirements Use cases Code","title":"Seeqret: Safely transferring code secrets"},{"location":"#introduction","text":"How do you communicate the set of secrets (passwords, API keys, etc.) that your code needs to run? You can't just write them in the code, because that would expose them to anyone who can read the code. You can't just send them in an email, because that would expose them to anyone who can read your email. You can't just write them on a sticky note, because that would expose them to anyone who can read your sticky note.","title":"Introduction"},{"location":"background/","text":"Prior art... There are many ways to store and use secrets, e.g.: Environment variables : It is popular, in e.g. kubernetes and javascript, to read secrets from environment variables. For development these are stored in .env files that are not checked into git/svn. These files contain the secrets in plain-text. Transferring secrets to a new server/devloper is a manual process where you create a new file and somehow get access to the secrets. Key vaults : E.g. Secureden or HashiCorp Vault (can be self hosted). These are usually expensive or complex to set up - or both. Key vaults usually have an API that you can use to get the secrets (setting this up is also expensive/complex/both). Secret management services : These are hosted key vaults, e.g. AWS Secrets Manager, Google Secret manager, Azure Key Vault, or hosted HashiCorp Vault. There is always an associated api to read the secrets. This can incur significant costs for large numbers of secrets and/or high usage. Encrypted files : This is usually a key/value file (.json/.yaml), where only the values are encrypted (e.g. SOPS . Every developer must have the same key to be able to use the file, but the file can be stored in git/svn. Assumptions You can make the following assumptions: https is secure the encryption algorithms are secure encrypted directories (Windows) are secure attrib +I %1 icacls %1 /grant %USERDOMAIN%\\%USERNAME%:(F) /T icacls %1 /inheritance:r cipher /e %1 encrypted private directories (Ubuntu) are secure. 0600 (read/write by owner only) directories (linux) are safe provided the user is not compromised.","title":"Background"},{"location":"background/#prior-art","text":"There are many ways to store and use secrets, e.g.: Environment variables : It is popular, in e.g. kubernetes and javascript, to read secrets from environment variables. For development these are stored in .env files that are not checked into git/svn. These files contain the secrets in plain-text. Transferring secrets to a new server/devloper is a manual process where you create a new file and somehow get access to the secrets. Key vaults : E.g. Secureden or HashiCorp Vault (can be self hosted). These are usually expensive or complex to set up - or both. Key vaults usually have an API that you can use to get the secrets (setting this up is also expensive/complex/both). Secret management services : These are hosted key vaults, e.g. AWS Secrets Manager, Google Secret manager, Azure Key Vault, or hosted HashiCorp Vault. There is always an associated api to read the secrets. This can incur significant costs for large numbers of secrets and/or high usage. Encrypted files : This is usually a key/value file (.json/.yaml), where only the values are encrypted (e.g. SOPS . Every developer must have the same key to be able to use the file, but the file can be stored in git/svn.","title":"Prior art..."},{"location":"background/#assumptions","text":"You can make the following assumptions: https is secure the encryption algorithms are secure encrypted directories (Windows) are secure attrib +I %1 icacls %1 /grant %USERDOMAIN%\\%USERNAME%:(F) /T icacls %1 /inheritance:r cipher /e %1 encrypted private directories (Ubuntu) are secure. 0600 (read/write by owner only) directories (linux) are safe provided the user is not compromised.","title":"Assumptions"},{"location":"commands/","text":"Commands seeqret init Initialize a new vault for a user in the current directory. This will create a subdirectory named seeqret containing three key files and the database. If on windows the SEEQRET environment variable will be set to point to this folder. You will be asked for username and email. The vault can not be located inside a repository or on a network drive for security reasons. seeqret add key $\u2771 seeqret add key NAME \"VALUE\" --app \"*\" --env \"*\" --app and --env defaults to \"*\" . seeqret list List the contents of the vault. seeqret add user $\u2771 seeqret add user Add a user to the database. You can only export secrets to known users. You will be prompted for username ( --username ), email ( --email ), and the url ( --url ) where the user's public key is located. TODO: add --pubkey flag. seeqret users List known users. seeqret export TO Create an export file that can be sent to \"bob\" $\u2771 seeqret export bob Create an export file for yourself (useful for moving the vault to a new computer/server). $\u2771 seeqret export self seeqret import FNAME Import an export file. Will only work if you are the intended receipient. seeqret upgrade Upgrade the database to the latest version. Top level help seeqret\u2771 seeqret --help Usage: seeqret [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: add Add a new secret, key or user export Export the vault to a user import-file Import a vault from a file init Initialize a new vault list List the contents of the vault upgrade Upgrade the database to the latest version users List the users in the vault add has two sub-commands seeqret\u2771 seeqret add --help seeqret \uf00c Usage: seeqret add [OPTIONS] COMMAND [ARGS]... Add a new secret, key or user Options: --help Show this message and exit. Commands: key Add a new key/value pair. user Add a new user to the vault from a public key.","title":"Command reference"},{"location":"commands/#commands","text":"","title":"Commands"},{"location":"commands/#seeqret-init","text":"Initialize a new vault for a user in the current directory. This will create a subdirectory named seeqret containing three key files and the database. If on windows the SEEQRET environment variable will be set to point to this folder. You will be asked for username and email. The vault can not be located inside a repository or on a network drive for security reasons.","title":"seeqret init"},{"location":"commands/#seeqret-add-key","text":"$\u2771 seeqret add key NAME \"VALUE\" --app \"*\" --env \"*\" --app and --env defaults to \"*\" .","title":"seeqret add key"},{"location":"commands/#seeqret-list","text":"List the contents of the vault.","title":"seeqret list"},{"location":"commands/#seeqret-add-user","text":"$\u2771 seeqret add user Add a user to the database. You can only export secrets to known users. You will be prompted for username ( --username ), email ( --email ), and the url ( --url ) where the user's public key is located. TODO: add --pubkey flag.","title":"seeqret add user"},{"location":"commands/#seeqret-users","text":"List known users.","title":"seeqret users"},{"location":"commands/#seeqret-export-to","text":"Create an export file that can be sent to \"bob\" $\u2771 seeqret export bob Create an export file for yourself (useful for moving the vault to a new computer/server). $\u2771 seeqret export self","title":"seeqret export TO"},{"location":"commands/#seeqret-import-fname","text":"Import an export file. Will only work if you are the intended receipient.","title":"seeqret import FNAME"},{"location":"commands/#seeqret-upgrade","text":"Upgrade the database to the latest version.","title":"seeqret upgrade"},{"location":"commands/#top-level-help","text":"seeqret\u2771 seeqret --help Usage: seeqret [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: add Add a new secret, key or user export Export the vault to a user import-file Import a vault from a file init Initialize a new vault list List the contents of the vault upgrade Upgrade the database to the latest version users List the users in the vault","title":"Top level help"},{"location":"commands/#add-has-two-sub-commands","text":"seeqret\u2771 seeqret add --help seeqret \uf00c Usage: seeqret add [OPTIONS] COMMAND [ARGS]... Add a new secret, key or user Options: --help Show this message and exit. Commands: key Add a new key/value pair. user Add a new user to the vault from a public key.","title":"add has two sub-commands"},{"location":"filter-strings/","text":"Filter spec Several commands take a filter-spec , which is a string with the following format: <app-spec>:<env-spec>:<name-spec> Each part (between colons) is required and uses glob syntax. Colon is not an allowed character in app/env/name values. * values can usually be omitted, i.e. foo:*:bar can be written as foo::bar . Examples all values *:*:* it could have been * but windows will do expansion on solitary stars, so :: and just : will work. all values for a specific app my-app:*:* or my-app:* or my-app: all development values for a specific app my-app:dev:* or my-app:dev: all names starting with PG *:*:PG* or ::PG* or PG* all names ending with _ID *_ID","title":"Filter spec"},{"location":"filter-strings/#filter-spec","text":"Several commands take a filter-spec , which is a string with the following format: <app-spec>:<env-spec>:<name-spec> Each part (between colons) is required and uses glob syntax. Colon is not an allowed character in app/env/name values. * values can usually be omitted, i.e. foo:*:bar can be written as foo::bar .","title":"Filter spec"},{"location":"filter-strings/#examples","text":"","title":"Examples"},{"location":"filter-strings/#all-values","text":"*:*:* it could have been * but windows will do expansion on solitary stars, so :: and just : will work.","title":"all values"},{"location":"filter-strings/#all-values-for-a-specific-app","text":"my-app:*:* or my-app:* or my-app:","title":"all values for a specific app"},{"location":"filter-strings/#all-development-values-for-a-specific-app","text":"my-app:dev:* or my-app:dev:","title":"all development values for a specific app"},{"location":"filter-strings/#all-names-starting-with-pg","text":"*:*:PG* or ::PG* or PG*","title":"all names starting with PG"},{"location":"filter-strings/#all-names-ending-with-_id","text":"*_ID","title":"all names ending with _ID"},{"location":"references/","text":"Code The code in the filecrypt.py file is from Asymetric Encryption which is well worth watching... The code in pgp_filecrypt.py contains the code needed to do pgp encryption/decryption (here you need to set the trust level when importing keys to the people you want to send encrypted messages to).","title":"References"},{"location":"references/#code","text":"The code in the filecrypt.py file is from Asymetric Encryption which is well worth watching... The code in pgp_filecrypt.py contains the code needed to do pgp encryption/decryption (here you need to set the trust level when importing keys to the people you want to send encrypted messages to).","title":"Code"},{"location":"requirements/","text":"Minimum Requirements different users/systems should have access to different subsets of the secrets. the secrets should not exist in plain-text when they are not used (e.g. a database password is only used when logging into the database - it shouldn't exist in memory outside of this process[^3]). a subset of secrets needs to be shared with new developers in a secure way. there should be a command line utility ( secrets ) to secrets set <key> <value> : set a secret secrets get <key> : get a secret secrets export <user> <keys..> export a subset of the secrets for transmission (e.g. by email) to a new developer secrets import <keys..> import keys received by e.g. email and a library/API to secrets.get(key) : get a secret (this should be a fast O(1) operation) the secrets should be easy to update[^1]. it should be possible to backup the secrets. (bonus) : the secrets should be easy to rotate[^2]. (bonus) : the secrets should be auditable[^4]. Use cases Starting from scratch: How do you set up the secrets system? Inviting users: How do you invite users and how do you communicate the secrets to them? Adding a secret: How do you communicate a new secret to the users? Updating a secret: How do you communicate an update to a secret? New user: How does a new user get access to the secrets? Backup: How do you backup the secrets and what is needed to restore the backup? Developer leaves: How do you revoke access to the secrets for a developer that leaves? footnotes [^1]: Updating means manually changing the secret (both in the storage and the service it protects), e.g. when a password expires/is compromised/a devloper leaves/etc. [^2]: Rotation is the process of periodically updating a secret. Ideally this is an automatic process that e.g. changes both the secret storage and the service it protects. [^3]: This is a defense-in-depth measure (in case the sanitizer fails to remove the secret from any traceback/logs/etc.) [^4]: Auditing means checking who has access to the secrets, which secrets were accessed, and when.","title":"Requirements"},{"location":"requirements/#minimum-requirements","text":"different users/systems should have access to different subsets of the secrets. the secrets should not exist in plain-text when they are not used (e.g. a database password is only used when logging into the database - it shouldn't exist in memory outside of this process[^3]). a subset of secrets needs to be shared with new developers in a secure way. there should be a command line utility ( secrets ) to secrets set <key> <value> : set a secret secrets get <key> : get a secret secrets export <user> <keys..> export a subset of the secrets for transmission (e.g. by email) to a new developer secrets import <keys..> import keys received by e.g. email and a library/API to secrets.get(key) : get a secret (this should be a fast O(1) operation) the secrets should be easy to update[^1]. it should be possible to backup the secrets. (bonus) : the secrets should be easy to rotate[^2]. (bonus) : the secrets should be auditable[^4].","title":"Minimum Requirements"},{"location":"requirements/#use-cases","text":"Starting from scratch: How do you set up the secrets system? Inviting users: How do you invite users and how do you communicate the secrets to them? Adding a secret: How do you communicate a new secret to the users? Updating a secret: How do you communicate an update to a secret? New user: How does a new user get access to the secrets? Backup: How do you backup the secrets and what is needed to restore the backup? Developer leaves: How do you revoke access to the secrets for a developer that leaves? footnotes [^1]: Updating means manually changing the secret (both in the storage and the service it protects), e.g. when a password expires/is compromised/a devloper leaves/etc. [^2]: Rotation is the process of periodically updating a secret. Ideally this is an automatic process that e.g. changes both the secret storage and the service it protects. [^3]: This is a defense-in-depth measure (in case the sanitizer fails to remove the secret from any traceback/logs/etc.) [^4]: Auditing means checking who has access to the secrets, which secrets were accessed, and when.","title":"Use cases"}]}